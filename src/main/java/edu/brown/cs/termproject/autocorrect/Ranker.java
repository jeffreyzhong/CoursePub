package edu.brown.cs.termproject.autocorrect;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Map.Entry;

import com.google.common.collect.ListMultimap;
import com.google.common.collect.MinMaxPriorityQueue;

/**
 * Ranker Class: This class contains three different ranking systems for all of
 * the suggestions generated by the SuggestionGenerator. The first is ranking
 * for inputs of two or more words. The second is ranking for single word
 * inputs. The third is my smart ranking.
 *
 * @author Jeffreyzhong
 */
public class Ranker {

  private HashMap<String, Integer> unigramMap;
  private ListMultimap<String, String> bigramSet;
  private ListMultimap<String, String> trigramSet;

  /**
   * Ranker Constructor: This constructor takes in the various data structures
   * needed to rank suggestions properly such as bigram probabilities, unigram
   * probabilities, and trigram probabilities.
   *
   * @param uniMap
   *          Map of all words to their frequencies
   * @param biMap
   *          Map of all words to a list of words that come after it
   * @param triMap
   *          Map of all words to a list of words that come two after it
   */
  public Ranker(HashMap<String, Integer> uniMap,
      ListMultimap<String, String> biMap, ListMultimap<String, String> triMap) {
    unigramMap = uniMap;
    bigramSet = biMap;
    trigramSet = triMap;

  }

  /**
   * This method is used to rank all single word inputs in the command line. It
   * takes in all of the suggestions generated by the three algorithms and
   * narrows it down to the top 5.
   *
   * @param toCorrect
   *          The word to autocorrect
   * @param prefix
   *          The list of all suggestions generated by the prefix algorithm
   * @param whitespace
   *          The list of all suggestions generated by the whitespace algorithm
   * @param levenshtein
   *          The list of all suggestions generated by the levenshtein algorithm
   * @return List of the five suggestions
   */
  public List<String> rankOnItsOwn(String toCorrect, List<String> prefix,
      List<String> whitespace, List<String> levenshtein) {

    HashMap<String, Integer> frequencies = new HashMap<String, Integer>();
    for (String word : prefix) {
      if (word.equals(toCorrect)) {
        frequencies.put(word, Integer.MAX_VALUE);

      } else {
        frequencies.put(word, unigramMap.get(word));
      }
    }
    for (String word : levenshtein) {
      if (word.equals(toCorrect)) {
        frequencies.put(word, Integer.MAX_VALUE);

      } else {
        frequencies.put(word, unigramMap.get(word));
      }
    }
    for (String word : whitespace) {
      if (word.split(" ")[0].equals(toCorrect)) {
        frequencies.put(word, Integer.MAX_VALUE);

      } else {
        frequencies.put(word, unigramMap.get(word.split(" ")[0]));
      }
    }
    // sort the suggestions
    MinMaxPriorityQueue<Entry<String, Integer>> pq = MinMaxPriorityQueue
        .orderedBy(new UnigramComparator(frequencies)).create();

    for (Entry<String, Integer> entry : frequencies.entrySet()) {
      if (!pq.contains(entry)) {
        pq.add(entry);
      }
    }

    List<String> finalResult = new ArrayList<String>();
    for (int i = 0; i <= 4; i++) {
      try {
        Entry<String, Integer> entry = pq.removeLast();
        finalResult.add(entry.getKey());

      } catch (NoSuchElementException e) {
        break;
      }
    }
    return finalResult;
  }

  /**
   * UnigramComparator Class: This private inner class is used to aid the
   * priority queue in sorting all of the suggestions for single word inputs. It
   * first looks at unigram probability and breaks possible ties with an
   * alphabetical rank.
   *
   * @author Jeffreyzhong
   */
  private static class UnigramComparator
      implements Comparator<Entry<String, Integer>> {

    private HashMap<String, Integer> frequencies;

    UnigramComparator(HashMap<String, Integer> map) {
      frequencies = map;
    }

    @Override
    public int compare(Entry<String, Integer> entry1,
        Entry<String, Integer> entry2) {
      Integer uniFreq1 = frequencies.get(entry1.getKey());
      Integer uniFreq2 = frequencies.get(entry2.getKey());
      Integer uniCompared = uniFreq1.compareTo(uniFreq2);

      if (uniCompared < 0 || uniCompared > 0) {
        return uniCompared;

      } else {
        return entry2.getKey().compareTo(entry1.getKey());
      }
    }

  }

  /**
   * This method is my smart ranking system. It basically creates a point system
   * based on bigram and trigram probability. If the input has more than three
   * words, then suggestions are given 3 points if they come after both the
   * previous word and the word that came two before. Suggestions are given 2
   * points if they come after only the previous word, 1 point of they come
   * after only the word that came two before, and 0 points if they come after
   * neither.
   *
   * @param toCorrect
   *          The word to autocorrect
   * @param wordBefore
   *          The word that came before
   * @param twoBefore
   *          The word that came two before
   * @param prefix
   *          List of all suggestions generated by the prefix algorithm
   * @param whitespace
   *          List of all suggestions generated by the whitespace algorithm
   * @param levenshtein
   *          List of all suggestions generated by the levenshtein algorithm
   * @return List of the top 5 smart ranked suggestions
   */
  public List<String> smartRank(String toCorrect, String wordBefore,
      String twoBefore, List<String> prefix, List<String> whitespace,
      List<String> levenshtein) {

    List<String> biList = bigramSet.get(wordBefore);
    List<String> triList = trigramSet.get(twoBefore);

    HashMap<String, Integer> biProb = new HashMap<String, Integer>();
    HashMap<String, Integer> triProb = new HashMap<String, Integer>();
    HashMap<String, Integer> suggestionsMap = new HashMap<String, Integer>();
    // keep track of how often the word came after wordBefore
    for (String word : biList) {
      if (biProb.containsKey(word)) {
        biProb.put(word, biProb.get(word) + 1);
      } else {
        biProb.put(word, 1);
      }
    }
    // keep track of how often the word came after the word two words before
    for (String word : triList) {
      if (triProb.containsKey(word)) {
        triProb.put(word, triProb.get(word) + 1);

      } else {
        triProb.put(word, 1);
      }
    }
    // assign point values
    for (String word : prefix) {
      boolean inBiList = biList.contains(word);
      boolean inTriList = triList.contains(word);

      if (word.equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (inBiList && inTriList) {
        suggestionsMap.put(word, 3);
      } else if (inBiList && !inTriList) {
        suggestionsMap.put(word, 2);
      } else if (!inBiList && inTriList) {
        suggestionsMap.put(word, 1);
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    for (String word : whitespace) {
      boolean inBiList = biList.contains(word);
      boolean inTriList = triList.contains(word);

      if (word.equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (inBiList && inTriList) {
        suggestionsMap.put(word, 3);
      } else if (inBiList && !inTriList) {
        suggestionsMap.put(word, 2);
      } else if (!inBiList && inTriList) {
        suggestionsMap.put(word, 1);
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    for (String word : levenshtein) {
      boolean inBiList = biList.contains(word);
      boolean inTriList = triList.contains(word);

      if (word.equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (inBiList && inTriList) {
        suggestionsMap.put(word, 3);
      } else if (inBiList && !inTriList) {
        suggestionsMap.put(word, 2);
      } else if (!inBiList && inTriList) {
        suggestionsMap.put(word, 1);
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    // sort all the suggestions
    MinMaxPriorityQueue<Entry<String, Integer>> pq = MinMaxPriorityQueue
        .orderedBy(new SmartComparator(biProb, triProb, unigramMap)).create();
    Iterator<Entry<String, Integer>> itr = suggestionsMap.entrySet().iterator();

    while (itr.hasNext()) {
      Entry<String, Integer> entry = itr.next();
      if (!pq.contains(entry)) {
        pq.add(entry);
      }
    }

    List<String> smartResult = new ArrayList<String>();
    for (int i = 0; i <= 4; i++) {
      try {
        Entry<String, Integer> entry = pq.removeLast();
        smartResult.add(entry.getKey());
      } catch (NoSuchElementException e) {
        break;
      }
    }
    return smartResult;
  }

  /**
   * SmartComparatorClass: This private inner class is used to aid the priority
   * queue in sorting all suggestions by my smart ranking system. First
   * comparing the points assigned to each word based on the system described
   * above, breaking ties with bigram probabilities, trigram probabilities,
   * unigram probabilities, and finally alphabetically.
   *
   * @author Jeffreyzhong
   */
  private static class SmartComparator
      implements Comparator<Entry<String, Integer>> {

    private HashMap<String, Integer> biMap;
    private HashMap<String, Integer> triMap;
    private HashMap<String, Integer> uniMap;

    SmartComparator(HashMap<String, Integer> bi, HashMap<String, Integer> tri,
        HashMap<String, Integer> uni) {
      biMap = bi;
      triMap = tri;
      uniMap = uni;
    }

    @Override
    public int compare(Entry<String, Integer> entry1,
        Entry<String, Integer> entry2) {
      Integer trigramRank = entry1.getValue().compareTo(entry2.getValue());
      if (trigramRank > 0 || trigramRank < 0) {
        return trigramRank;

      } else {
        Integer biMap1 = biMap.get(entry1.getKey());
        Integer biMap2 = biMap.get(entry2.getKey());
        Integer bigramProb = 0;

        if (biMap1 != null && biMap2 != null) {
          bigramProb = biMap.get(entry1.getKey())
              .compareTo(biMap.get(entry2.getKey()));
        }
        if (bigramProb > 0 || bigramProb < 0) {
          return bigramProb;

        } else {
          Integer triMap1 = triMap.get(entry1.getKey());
          Integer triMap2 = triMap.get(entry2.getKey());
          Integer trigramProb = 0;

          if (triMap1 != null && triMap2 != null) {
            trigramProb = triMap.get(entry1.getKey())
                .compareTo(triMap.get(entry2.getKey()));
          }
          if (trigramProb > 0 || trigramProb < 0) {
            return trigramProb;

          } else {
            Integer uniMap1 = uniMap.get(entry1.getKey());
            Integer uniMap2 = uniMap.get(entry2.getKey());
            Integer unigramProb = 0;

            if (uniMap1 != null && uniMap2 != null) {
              unigramProb = uniMap.get(entry1.getKey())
                  .compareTo(uniMap.get(entry2.getKey()));
            }
            if (unigramProb > 0 || unigramProb < 0) {
              return unigramProb;

            } else {
              return entry2.getKey().compareTo(entry1.getKey());
            }
          }
        }
      }
    }

  }

  /**
   * This method ranks all suggestions if the input had two or more words. It
   * first ranks all suggestions by how likely they are to come after the
   * previous word in the input. HashMaps are used to keep tabs on frequencies
   * of each word.
   *
   * @param toCorrect
   *          The word to autocorrect
   * @param wordBefore
   *          The word that came before
   * @param prefix
   *          List of all suggestions generated by the prefix algorithm
   * @param whitespace
   *          List of all suggestions generated by the whitespace algorithm
   * @param levenshtein
   *          List of all suggestions generated by the levenshtein algorithm
   * @return List of top 5 suggestions
   */
  public List<String> rankWithWordBefore(String toCorrect, String wordBefore,
      List<String> prefix, List<String> whitespace, List<String> levenshtein) {

    List<String> allThatComesAfter = bigramSet.get(wordBefore);
    HashMap<String, Integer> frequencies = new HashMap<String, Integer>();
    HashMap<String, Integer> suggestionsMap = new HashMap<String, Integer>();

    for (int i = 0; i < allThatComesAfter.size(); i++) {
      String word = allThatComesAfter.get(i);

      if (frequencies.containsKey(word)) {
        frequencies.put(word, frequencies.get(word) + 1);
      } else {
        frequencies.put(word, 1);
      }
    }
    for (int i = 0; i < prefix.size(); i++) {
      String word = prefix.get(i);

      if (word.equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (allThatComesAfter.contains(word)) {
        suggestionsMap.put(word, frequencies.get(word));
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    for (int i = 0; i < levenshtein.size(); i++) {
      String word = levenshtein.get(i);

      if (word.equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (allThatComesAfter.contains(word)) {
        suggestionsMap.put(word, frequencies.get(word));
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    for (int i = 0; i < whitespace.size(); i++) {
      String word = whitespace.get(i);

      if (word.split(" ")[0].equals(toCorrect)) {
        suggestionsMap.put(word, Integer.MAX_VALUE);
      } else if (allThatComesAfter.contains(word.split(" ")[0])) {
        suggestionsMap.put(word, frequencies.get(word.split(" ")[0]));
      } else {
        suggestionsMap.put(word, 0);
      }
    }
    // sort the suggestions
    MinMaxPriorityQueue<Entry<String, Integer>> pq = MinMaxPriorityQueue
        .orderedBy(new FrequencyComparator(unigramMap)).create();
    Iterator<Entry<String, Integer>> itr = suggestionsMap.entrySet().iterator();

    while (itr.hasNext()) {
      Entry<String, Integer> entry = itr.next();
      if (!pq.contains(entry)) {
        pq.add(entry);
      }
    }

    List<String> finalResult = new ArrayList<String>();
    for (int i = 0; i <= 4; i++) {
      try {
        Entry<String, Integer> entry = pq.removeLast();
        finalResult.add(entry.getKey());
      } catch (NoSuchElementException e) {
        break;
      }
    }

    return finalResult;
  }

  /**
   * FrequencyComparator Class: This private inner class first sorts entries by
   * their bigram probability, breaking ties with unigram probabilities and
   * alphabetically.
   *
   * @author Jeffreyzhong
   *
   */
  private static class FrequencyComparator
      implements Comparator<Entry<String, Integer>> {

    private HashMap<String, Integer> unigramMap;

    FrequencyComparator(HashMap<String, Integer> map) {
      unigramMap = map;
    }

    @Override
    public int compare(Entry<String, Integer> val1,
        Entry<String, Integer> val2) {
      int bigramFreq = val1.getValue().compareTo(val2.getValue());

      if (bigramFreq > 0 || bigramFreq < 0) {
        return bigramFreq;
      } else {
        String val1Split = val1.getKey().split(" ")[0];
        String val2Split = val2.getKey().split(" ")[0];
        Integer unigramFreq1 = unigramMap.get(val1Split);
        Integer unigramFreq2 = unigramMap.get(val2Split);
        int unigramCompare = unigramFreq1.compareTo(unigramFreq2);

        if (unigramCompare > 0 || unigramCompare < 0) {
          return unigramCompare;

        } else {
          return val2.getKey().compareTo(val1.getKey());
        }
      }
    }
  }

}
